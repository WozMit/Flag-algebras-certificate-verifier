\documentclass[11pt,a4paper,reqno]{amsart}
\usepackage{mystyle}

\begin{document}

\title[Verification of flag algebras generated results]{Verification of flag algebras generated results}

\maketitle

\textbf{\large Full verification}

The verification programs are written in Python 3. The full verification, which takes
around 85 hours in a modern personal computer, can be performed by executing the
\verb|full-verify| program inside a folder containing all six certificates:

\begin{Verbatim}[frame=single, fontsize=\small]
$ python3 full-verify.py
\end{Verbatim}

The program calls the \verb|validator| and \verb|verifier| programs on each
certificate. The calls are made in the following way:

\begin{Verbatim}[frame=single, fontsize=\small]
$ python3 validator.py prop_3_1_c5k4.pickle
$ python3 verifier.py prop_3_1_c5k4.pickle
\end{Verbatim}

\textbf{\large Validate objectives and assumptions}

The \verb|validator| program loads a certificate as a Python pickle file and verifies
that that the objective function and positivity assumptions of its corresponding
proposition are correctly translated into the certificate. Its usage message is the
following.

\begin{Verbatim}[frame=single, fontsize=\small]
usage: validator.py [-h] {prop_3_1_c5k4.pickle,prop_3_1_c7.pickle,
                          prop_3_2_c5k4.pickle,prop_3_2_c7.pickle,
                          prop_3_3_c5k4.pickle,prop_3_3_c7.pickle}

Validates that the objectives and assumptions of a given certificate correspond
to those in the corresponding proposition.

positional arguments:
  {prop_3_1_c5k4.pickle,prop_3_1_c7.pickle,prop_3_2_c5k4.pickle,
   prop_3_2_c7.pickle,prop_3_3_c5k4.pickle,prop_3_3_c7.pickle}
                        path of the pickle file

options:
  -h, --help            show this help message and exit

examples:
  $ python validator.py prop_3_1_c5k4.pickle
\end{Verbatim}

The objective functions and positivity assumptions for each propositions can be found
in the following locations.

\begin{itemize}
\item Proposition~$3.1$: Lines~$179$--$186$.
\item Proposition~$3.2$: Lines~$189$--$250$.
\item Proposition~$3.3$: Lines~$253$--$374$.
\end{itemize}

\textbf{\large Verify the certificates}

The verifier program loads a certificate as a Python pickle file, interactively asks
for a pair of indices, and then verifies the constraints corresponding to the
user-specified range. Its usage message is the following.

\begin{Verbatim}[frame=single, fontsize=\small]
usage: verifier.py [-h] [-p] [-v {1,2,3}] certificate

A simple flag algebras certificate verifier.

positional arguments:
  certificate           path of the pickle file

options:
  -h, --help            show this help message and exit
  -p, --partial         partial verification
  -v {1,2,3}, --verbose {1,2,3}
                        verbosity level
                        default: 1

examples:
  $ python verify.py c5k4-bad-missing.pickle

  $ python verify.py c5k4-bad-missing.pickle -p
  Enter two integers in the range [1,28080] (e.g., `1 14040'): 1 10

  $ python verifier.py c5k4-bad-missing.pickle -p -v 2
  Enter two integers in the range [1,28080] (e.g., `1 14040'): 5 5
\end{Verbatim}

\textbf{\large Verifier specification}

We work in the theory of~$3$-uniform hypergraphs, where every vertex is either red or
blue. For a type~$\tau$ and integers~$m' \leq m$ such
that~$2m' - \left|\tau\right| \leq m$, we make the following definitions.
\begin{itemize}
\item $\cF_m^\tau$ is the set of all flags with type~$\tau$ ($\tau$-flags) with~$m$ vertices in
  the theory. We also let~$\cF_m = \cF_m^\varnothing$.
\item $\reals F_m^\tau$ is the set of formal real linear combinations of flags
  from~$\cF_m^{\tau}$.
\item For~$\tau$-flags~$H_1, H_2 \in \cF_{m'}^{\tau}$,
  let~$H_1 \times H_2 = \sum_{G \in \cF_{2m' - \left| \tau \right|}^\tau} d\paren{H_1, H_2, G} G$.
\item
  $\cF_{m'}^{\tau} \otimes \cF_{m'}^{\tau} \in \paren{\reals \cF_{2m' -
      \left|\tau\right|}^\tau}^{\cF_{m'}^\tau \times \cF_{m'}^\tau}$ is a symmetric matrix with lines
  indexed by~$\cF_{m'}^{\tau}$ whose~$\paren{H_1, H_2}$-entry is~$H_1 \times H_2$.
\item
  $\lllbr \cF_{m'}^{\tau} \otimes \cF_{m'}^{\tau} \rrrbr_{\tau} \in \paren{\reals \cF_{2m' -
      \left|\tau\right|}}^{\cF_{m'}^\tau \times \cF_{m'}^\tau}$ is the matrix obtained
  from~$\cF_{m'}^{\tau} \otimes \cF_{m'}^{\tau}$ by applying entry-wise the averaging
  operator. Each entry is a linear combination of flags
  from~$\cF_{2m' - \left|\tau\right|}$.
\item For a flag~$F \in \cF_m$, we
  let~$M_F^{\tau, m} \in \reals^{\cF_{m'}^\tau \times \cF_{m'}^\tau}$ be the real symmetric matrix
  obtained from~$\lllbr \cF_{m'}^{\tau} \otimes \cF_{m'}^{\tau} \rrrbr_{\tau}$ by applying
  entry-wise the~$d(\cdot, F)$ density operator.
\end{itemize}
We now fix:
\begin{enumerate}[label=(\textit{\roman*})]
\item\label{item:target} $T \in \reals\cF_m$, a target linear combination of flags,
\item\label{item:result} $\lambda \in \reals$, a bound,
\item\label{item:types} $(\tau_1, n_1), \dots, (\tau_k, n_k)$, a sequence of types and sizes,
\item\label{item:matrices} $X^{\tau_1}, \dots, X^{\tau_k}$, a sequence of square matrices.
\item\label{item:e_vector} $e_1, \dots, e_p$, a sequence of coefficients~$e_i \in \reals$.
\item\label{item:positives} $f^{(1)}, \dots, f^{(p)}$, a sequence of elements~$f^{(i)} \in \reals\cF_m$.
\end{enumerate}
Then, we need to verify that:
\begin{equation}
  \label{eq:positive_semidefinite}
  \text{the matrices } X^{\tau_1}, \dots, X^{\tau_k} \text{ are positive semidefinite,}
\end{equation}
and for all~$F \in \cF_m$ and coefficients~$c_F \geq 0$,
\begin{equation}
  \label{eq:all_constraints}
  \lambda - d(T, F) = \sum_{i \in [k]} \langle M_F^{\tau_i, m_i}, X^{\tau_i}\rangle + \sum_{i \in [p]} e_i d(f^{(i)}, F) + c_F.
\end{equation}
The verification of~\eqref{eq:positive_semidefinite} is done by attempting to decompose a
matrix~$M = LDL^{\text{T}}$, where~$L$ is a lower triangular matrix with~$1$'s on the
diagonal, and~$D$ is a diagonal matrix. If the decomposition reconstructs~$M$, and
all diagonal entries of~$D$ are non-negative, then we conclude that~$M$ is positive
semidefinite.

Given that the verification of~\eqref{eq:all_constraints} may be computationally
intensive, the program verifies a user-specified subset of~$\cF_m$. More precisely,
given an ordering of the set
\begin{equation}
  \label{eq:zero_flags}
  \cF_m = \set{F_1, F_2, \dots, F_\ell},
\end{equation}
specified by the certificate, and a user-specified pair of indices~$i, j$, the
program verifies~\eqref{eq:all_constraints} for~$F_p$, with~$i \leq p \leq j$. By default, this range
is~$[\ell]$, i.e., the program completely verifies~\eqref{eq:all_constraints}. If the
verification fails at some point, the program stops and reports the failure.

A certificate is a Python pickle file containing a serialized dictionary with string
keys. All numerical values in the certificate are \verb|Fraction| objects. The
structure of the dictionary is as follows:

\begin{itemize}
\item \verb|"target"|: The target element in~\ref{item:target}, given as a
  list~$(t_i)_{i \in [\ell]}$, where~$T = t_1F_1 + \cdots t_\ell F_\ell$.
\item \verb|"result"|: The value in~\ref{item:result}.
\item \verb|"X matrices"|: List~$(X^{\tau_i})_{i \in [k]}$ of the matrices in~\ref{item:matrices}. Each
  matrix is given as a list representing a flattened matrix.
\item \verb|"e vector"|: List~$(e_i)_{i \in [p]}$ of coefficients in~\ref{item:e_vector}.
\item \verb|"positives"|: List~$(f^{(i)})_{i \in [p]}$ of positivity constraints
  in~\ref{item:positives}. Each element~$f^{(i)}$ is given as a
  list~$(f^{(i)}_j)_{j \in [\ell]}$, where~$f^{(i)} = f^{(i)}_1 F_1 + \cdots + f^{(i)}_\ell F_\ell$.
\item \verb|"base flags"|: List~$(F_i)_{i \in [\ell]}$ of the flags in~\eqref{eq:zero_flags}. Each
  flag is given as a tuple with the following values:
  \begin{itemize}
  \item Integer \verb|k|, the number of vertices in the flag. The vertices of the flag
    are the integers~$0, 1, \dots, k - 1$.
  \item Tuple \verb|t| of integers, the typed vertices of the flag in the labeling
    order. So, \verb|t[0]| is the vertex assigned to label~$0$, and so on.
  \item Tuple or ordered pairs \verb|(r, l)| identifying relations. The value \verb|r| is
    the name of the relation, one of the strings \verb|edges|, \verb|C0| or
    \verb|C1|. The value \verb|l| is a tuple identifying the elements of the
    relation. Each element of the relation is a tuple containing the vertices in the
    relation. For example, this is a valid tuple of ordered pairs:
    \verb|( ("edges", ((0, 1, 2)) ), ("C0", ((0), (1)) ), ("C1",(2)) )|. The vertices
    in the relation \verb|C1| are the blue vertices. Every other vertex (i.e., those
    in \verb|C0|) is red. The relations \verb|C0| and \verb|C1| are either both
    present, or both missing, in which case all the vertices are red.
  \end{itemize}
\item \verb|"typed flags"|: Dictionary, where keys are pairs \verb|(m,t)|, where \verb|m|
  is an integer, and \verb|t| is a type~$\tau_i$ from~\ref{item:types} in the flag format specified
  in the previous item. For a key~$(m_i, \tau_i)$, its corresponding value is a list of
  the elements in~$\cF_{m_i}^{\tau_i}$ in flag format.
\item \verb|"slack vector"|: List~$(c_{F_i})_{i \in [\ell]}$ of the non-negative slack
  coefficients in~\eqref{eq:all_constraints}.
\end{itemize}

\end{document}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: t
%%% End:
